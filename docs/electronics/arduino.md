## Arduino 
Arduino is C++ simplified wrapper and auto code generator

```cpp
// Arduino code
void setup() 
{

}

void loop() 
{

}
```

```cpp
// Arduino converts above code into cpp 

// Arduino Core Library which includes pinMode, digitalWrite, analogRead, Serial object etc
#include <Arduino.h>            

// Functions
void setup()
{
    // initialization code
}

void loop()
{
    // main logic
}

// The actual main function (generated by Arduino)
int main(void) 
{
    init();         // Initialize Arduino Hardware

    setup();        // Call you setup once

    for(;;)         // Infinite loop (same as while(1))
    {
        loop();     // Call loop function repeatedly

    }

    return 0;       // Never reached
}
```

```cpp
// Normally in c++ we nee to write as
HardwareSerial Serial(0);

// But Arduino does all of that internally, so we only write
Serial.begin(9600);
```

## Arduino Simplifies

- No need to write main() function, arduino auto generates it.

- Includes Header files

- Provides Global Objects automatically such as (Serial, Wire, SPI)

## Boards Manager
By default only Arduino AVR boards are installed, we need to add links to have access to esp32, esp8266 and rp2350 boards.
> Espressif System stopped supporting ESP8266, but these are widely available in market and at very low price. Hence, community is supporting ESP8266 board manager.

| Boards | Publisher | Link |
| --- | --- | --- |
| ESP32 | Espressif Systems | https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json |
| ESP8266 | Community | http://arduino.esp8266.com/stable/package_esp8266com_index.|
| RP2350 | earlephilhower | https://github.com/earlephilhower/arduino-pico/releases/download/global/package_rp2040_index.json |


## Basic Structure of Arduino Code

Arduino require two functions, ie setup and loop function for program to work.

```cpp
void setup() {
    // preparation
    // runs only once at the start
}

void loop() {
    // execution
    // runs again and again forever
}

```

### setup()
setup() function is used to intialize pinMode or begin serial. 

## Functions
```cpp
type functionName (parameters)
{
    statements;
}

// type is to indicate return type, such as int, float, str etc, if nothing gets returned it will be void.

int delayVal()
{
    int v;                  // create temporary variable 'v'
    v = analogRead(pot);    // read potentiometer value
    v /= 4;                 // converts 0-1023 to 0 to 255
    return v;               // return final value
}

// intializing variable
type inputVariable;

// declaring variable 
type inputVariable = 0;

// Global Variable declared before setup() function

int value;

void setup()
{
    // no setup needed
}

// Local variable are declared inside functions

```
## Constants
Arduino Language has a few predefined values, which are constants. They are used to make the programs easier to read. 
>Constants are written in CAPTIAL letters

- TRUE/FALSE
- HIGH/LOW
- INPUT/OUTPUT
- INPUT_PULLUP

INPUT_PULLUP constant is used with pinMode() function to enable the microcontroller to use internal pull-up resistor

```cpp
pinMode(7, INPUT_PULLUP); 

// this configues the pin as INPUT and with an internal 20 - 50 k ohm pull-up resistor connected to 5v or 3.3v

// this ensures default state is HIGH or 5V,and when pressing a button connects it to GND, giving a stable LOW.
```

- Arduino Boards has only INPUT_PULLUP only
- ESP32 Boards has INPUT_PULLDOWN also

## pinMode

```cpp
pinMode(pin, mode);

pinMode(pin, OUTPUT);   

pinMode(pin);       // mode default value is INPUT
```

pinmode is a function, used in setup() function to configure a specified pin to behave either as an INPUT or an OUTPUT


## digitalRead

```cpp
digitalRead(pin)
```

digitalRead is a function, used to read the value from specified digital pin with the result either HIGH or LOW.

pin value can be from 0 - 13

## digitalWrite
```cpp
digitalWrite(pin, value)
```

digitalWrite is a function, used to write / outputs either logic level HIGH or LOW value to specified digital pin.

pin value can be from 0 - 13

## analogRead
```cpp
analogRead(pin)
```

analogRead is a function, used to reads the value from a specified analog pin with a 10 bit resolution. 

- 8 bit will result in 256 values (0 - 255)
- 10 bit will result in 1024 values (0 - 1023)

analog pin value from 0 - 5

> Analog pins unlike digital pins, do not need pinMode, to be first declared as INPUT or OUTPUT

Digital pins are bidirectional, however, analog pins are input only. Analog pins uses ADC hardware (Analog to Digital Converter).

Analog pins can be used as Digital Signals also.

## analogWrite
```cpp
analogWrite(pin, value)
```

analogWrite function, writes pseudo-analog value using hardware enabled PWM (Pulse Width Modulation). PWM is digital. it rapidly toggles between HIGH (5v) and LOW (Ov), by varying percentage of time, it create average voltage. 

> analogWrite(pin, 128) on a 0-255 scale means 50%, dutycycle average of 0v and 5v is 2.5v. 

Pin is still outputting digital pulses, just very quickly. only certain digital pins support PWM (marked with ~) like 3, 5, 6, 9, 10, 11. These digital pins have timer hardware to generate the PWM Signal.

> analogWrite() is digitalWrite with PWM, it does not output analog signals, which require  DAC (Digital to Analog Converter). Arduino boards dont have DAC hardware, so they use PWM.

## delay
delay(ms) pauses program for the amount of time as specified in milliseconds. 1000 milliseconds = 1 sencond

## delayMicroseconds
delayMicroseconds(us) pauses program for the time specified in microseconds. 1000 microseconds = 1 milli seconds and 10,00,000 microsecond = 1 second. Microseconds are used when we need precise timing. delay function is accurate to millisecond. Microseconds play important role for creating pulse for ultrasonic sensor (10 microsecond), and also in Pulse Width Modultation, where accuracy is critical.

## millis
millis() function returns the number of milliseconds since the arduino board began running.
> number will overflow after 9 hours.ie 3,24,00,000 milliseconds. 

```cpp
// Misc built in functions
min(x,y);
max(x,y);
random(max);
random(min, max);
```
## Serial

Serial is an object (an instance of a class) of HardwareSerial Class. Methods (Functions of the class) available are as under
```cpp
Serial.begin(rate)              // opens serial port and set the baud rate for serial data transmission
Serial.print()                  // prints data to serial port with carriage return
Serial.println()                // prints data to serial port
Serial.write()                  // 
Serial.available()              

// Check if data is waiting, returns int (number of bytes in waiting in receive buffer ie SRAM, Arduino Nano has 64 Bytes capacity, so anything after 64 bytes is discarded (FIFO), First In First Out). If we read memory is cleared.

// 0 = no data
// > 0 = that many number of bytes are ready to read

Serial.read()                   

// read one byte

// 0 - 255 = the byte that was read
// -1 = No data available in buffer (buffer empty)

// always check available() before read() to avoid -1

```
### Serial.write vs Serial.print

Serial.write() sends raw binary data (bytes) without any conversion. It is mainly used in GPS. Ex : Ublox ZED F9P, generates binary data in ubx / bin format not ASCII format. Then using Ublox uCenter, we can get more information using this .bin file or .ubx file. write() function to be used with binary sensory data. 

Serial.write() can also be used as relay or bridge, to send exact binary bytes to another micro controller or computer. Read Byte from buffer stack and send exact byte through tx pin.

Serial.print() converts data to human-readable ASCII text before sending. print() function to be used with ASCII character.

## HardwareSerial
HardwareSerial is a class provided by the Arduino core to interface with microcontroller hardware UART peripherals.

```cpp
// Normally in c++ we nee to write as
HardwareSerial Serial(0);

// But Arduino does all of that internally, so we only write
Serial.begin(9600);

// Boards like esp32 have more than 1 UART hardware, so we can create several UART communications.

HardwareSerial Serial(0);       // On first UART Hardware with number 0

HardwareSerial Gps(1);          // on second UART Hardware with number 1
```

HardwareSerial code is different for different boards like AVR & ESP32.

```cpp
// HardwareSerial.h (AVR)

void begin(unsigned long baud, uint8_t config)      

// default config value is SERIAL_8N1. (8 bit data, no check, 1 stop)
```

```cpp
// HardwareSerial.h (ESP32)

void begin(unsigned long baud,
            uint32_t config,
            int rxPin,
            int txPin,
            bool invert = flase,
            unsigned long timeout_ms = 20000,
            uart_port_t uart = UART_NUM_1);

// so we need to specify atleast baud, config, rxPin and txPin, rest all are default.

// UART0 can be initiated with only baud argument, as rest are default, but for UART1, UART2 minimum 4 arguments are required.
```

## pulseIn

```cpp
pulseIn(pin, value);

pulseIn(pin, value, timeout);   //  timeout default value is 1 second.
```
pulseIn() function measures the duration of a pulse on a digital pin. It waits for the pin to go HIGH or LOW, starts timing, then waits for it to return to original state. pulseIn() function returns a unsigned long value ie pulse duration in microseconds.

## define

```cpp
#define LED_PIN 13
```
- No variable int created, saved 4bytes of memory.
- No Type safety (#define can be used aganist for int, float, string etc. it replaces text with value). like global constants.
- It is old style to save memory. not a recommended method.

```cpp
// old style (still works, saves RAM)
#define LED_PIN 13

// Modern style (Recommended)
const int LED_PIN 13
```
## SD Library

```cpp
SD.begin(chipSelect);               // check if SD card mounted or not
SD.open("test.txt", FILE_WRITE)     // write to file
SD.open("test.txt")                 // read file
```

## File Library
## interupts
 


